-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module CMM.Par where
import CMM.Abs
import CMM.Lex
import CMM.ErrM

}

%name pProgram Program
%name pDef Def
%name pListDef ListDef
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  'int' { PT _ (TS _ 3) }
  'main' { PT _ (TS _ 4) }
  '{' { PT _ (TS _ 5) }
  '}' { PT _ (TS _ 6) }

%%


Program :: { Program }
Program : ListDef { CMM.Abs.PDefs (reverse $1) }
Def :: { Def }
Def : 'int' 'main' '(' ')' '{' '}' { CMM.Abs.DFun }
ListDef :: { [Def] }
ListDef : {- empty -} { [] } | ListDef Def { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

